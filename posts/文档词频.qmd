---
title: 分面图的因子变量排序
categories: [R, text data]
---

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(tidytext)
theme_set(hrbrthemes::theme_ipsum_rc())
update_geom_defaults("pointrange", new = list(size = 1.2, linewidth = 1.5))
```

一般在绘制条形图或克里夫兰点图时，会按照柱子或点的高低对变量进行排序，这样绘制出的图整洁美观。

比如

```{r}
#| layout-ncol: 2
#| fig-cap: 
#|   - 排序前
#|   - 排序后
pop_data <- population %>% 
  filter(year == 1995) %>% 
  slice_head(n = 10)


pop_data %>% 
  ggplot(aes(country, population)) +
  geom_pointrange(aes(ymin = 0, ymax = population)) +
  scale_y_continuous(labels = scales::label_comma()) +
  coord_flip() 


pop_data %>% 
  mutate(country = fct_reorder(country, population)) %>% 
  ggplot(aes(country, population)) +
  geom_pointrange(aes(ymin = 0, ymax = population)) +
  scale_y_continuous(labels = scales::label_comma()) +
  coord_flip()
```

上面的排序是借助`fct_reorder()`函数实现的。最近在学习文本数据处理时，发现这种方法在分面时会出错。

```{r}
exm_data <- tibble(
  x = rep(LETTERS[1:5], 2),
  y = sample(1:10),
  z = c(rep("group1", 5), rep("group2", 5))
)

exm_data
```

```{r}
exm_data %>% 
  group_by(z) %>% 
  mutate(x = fct_reorder(x, y)) %>% 
  ggplot(aes(x, y, color = z)) +
  geom_pointrange(aes(ymin = 0, ymax = y), show.legend = FALSE) +
  facet_wrap(~ z, nrow = 1, scales = "free") +
  coord_flip() +
  scale_color_brewer(palette = "Dark2")
```

可以看出，group1组别中的排序是正确的，group2组中的排序是混乱的。虽然在`fct_reorder()`前使用了`group_by()`，但是变量`x`并没有真的在两个组内分别排序。因为group1和group2的数据同处于同一个数据框内，所以变量`x`作为因子变量不能有两种排序。

举个例子，我们按照既然不同的排序生成两组因子变量，然后将他们合并成一列

```{r}
#| layout-ncol: 2
dt_a <- tibble(fct_var = factor(c("A", "B", "C", "D"), levels = c("A", "B", "C", "D")),
               id = "a")
dt_b <- tibble(fct_var = factor(c("A", "B", "C", "D"), levels = c("D", "C", "B", "A")),
               id = "b")

dt_bind <- bind_rows(dt_a, dt_b)
dt_bind
```

但此时因子变量`fct_var`只有一种排序。

```{r}
levels(dt_bind$fct_var)
```

因此，在绘制分面图形时，不能用`fct_reorder()`来调整因子变量的排序。

`tidytext`包的`reorder_within()`和`scale_*_reordered()`可以解决这个问题。

```{r}
exm_data %>% 
  mutate(x = reorder_within(x, by = y, within = z)) %>% 
  ggplot(aes(x, y, color = z)) +
  geom_pointrange(aes(ymin = 0, ymax = y), show.legend = FALSE) +
  facet_wrap(~ z, scales = "free_y") +
  scale_x_reordered() +
  coord_flip()
```

这个方法的本质是先把因子变量和用于分面的变量合并成一个新的因子变量，再对这个新的因子变量进行排序。

```{r}
exm_data %>% 
  mutate(x = reorder_within(x, by = y, within = z))
```

相当于

```{r}
exm_data %>% 
  mutate(x = str_c(x, z, sep = "__"),
         x = fct_reorder(x, y))
```
