{
  "hash": "3e930ea97bbbb4a6c8ca6945af34e615",
  "result": {
    "markdown": "---\ntitle: 实现简单线性回归\ncategories: [R, econometrics]\ndate: \"2024-03-25\"\n---\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ntheme_set(hrbrthemes::theme_ipsum_rc())\n```\n:::\n\n\n\n准备花几期时间，自己写代码，实现常用的计量方法。\n\n生成模拟数据\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:4\nnames(x) <- LETTERS[1:4]\ndf <- tibble(\n  x1 = runif(1000, -10, 10),\n  x2 = sample(1:20, 1000, replace = TRUE),\n  x3 = sample(LETTERS[1:4], 1000, replace = TRUE),\n  error = rnorm(1000, sd = 1000),\n  y = 1 + 2 * x1 + 3 * x2 + x[x3]\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 5\n       x1    x2 x3     error     y\n    <dbl> <int> <chr>  <dbl> <dbl>\n 1 -7.41      8 A      -619. 11.2 \n 2  0.525    12 C     -2573. 41.1 \n 3  9.44      5 C      -587. 37.9 \n 4  7.74      1 D      -789. 23.5 \n 5 -8.20      2 C     -1028. -6.40\n 6  0.358    13 C       224. 43.7 \n 7  3.76      3 A      -958. 18.5 \n 8 -3.35     13 B      -877. 35.3 \n 9 -9.83     13 A      -276. 21.3 \n10  3.04     15 C     -1007. 55.1 \n# ℹ 990 more rows\n```\n:::\n:::\n\n\n# 步骤拆解\n\n### step 1: 根据formula生成矩阵\n\n因为`formula`是R里面一个特殊的`class`，他的具体机制我没弄清楚，所以这一步用R中的`model.matrix.lm()`实现\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ x1 + x2 + x3\ndf_model <- model.frame(formula, df)\nX <- model.matrix.lm(df_model)\nhead(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  (Intercept)         x1 x2 x3B x3C x3D\n1           1 -7.4089317  8   0   0   0\n2           1  0.5251729 12   0   1   0\n3           1  9.4359070  5   0   1   0\n4           1  7.7402444  1   0   0   1\n5           1 -8.2020473  2   0   1   0\n6           1  0.3581042 13   0   1   0\n```\n:::\n\n```{.r .cell-code}\nY <- model.response(df_model)\nhead(Y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        1         2         3         4         5         6 \n11.182137 41.050346 37.871814 23.480489 -6.404095 43.716208 \n```\n:::\n:::\n\n\n### step 2: 得到回归系数\n\n假设对于总体数据来说：\n\n$$\n\\mathbf Y = \\mathbf X \\boldsymbol \\beta + \\boldsymbol \\epsilon\n$$\n\n\n但是我们得到的拟合方程是：\n\n$$\n\\hat{\\mathbf Y} = \\mathbf X \\hat{\\boldsymbol \\beta}\n$$\n\n\n\n\n且\n\n$$\n\\begin{align}\n\\boldsymbol e &= \\mathbf Y - \\hat{\\mathbf Y} \\\\\n&= \\mathbf Y - \\mathbf X \\hat{\\boldsymbol \\beta}\n\\end{align}\n$$\n\n要想使$\\mathbf Y - \\hat{\\mathbf Y}$最小，则$\\boldsymbol e$与$\\mathbf X$正交，即\n\n\n$$\n\\begin{align}\n&\\mathbf {X^T (Y - X\\hat{\\beta})} = \\mathbf {0} \\\\\n&\\mathbf {\\hat{\\beta}} = \\mathbf {(X^T X)^{-1}X^TY} \n\\end{align}\n$$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_beta <- function(X, Y) {\n  solve(crossprod(X, X)) %*% crossprod(X, Y)\n}\nbeta <- get_beta(X, Y)\nbeta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]\n(Intercept)    2\nx1             2\nx2             3\nx3B            1\nx3C            2\nx3D            3\n```\n:::\n:::\n\n\n### step 3: 求出拟合值和误差\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_fit <- function(X, beta) {\n  X %*% beta\n}\n\nY_hat <- get_fit(X, beta)\nhead(Y_hat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       [,1]\n1 11.182137\n2 41.050346\n3 37.871814\n4 23.480489\n5 -6.404095\n6 43.716208\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_err_vec <- function(Y, Y_hat) {\n  Y - Y_hat\n}\nerr_vec <- get_err_vec(Y, Y_hat)\nhead(err_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n1 -5.506706e-14\n2 -4.263256e-14\n3 -5.684342e-14\n4 -4.618528e-14\n5 -7.105427e-14\n6 -4.263256e-14\n```\n:::\n:::\n\n\n### step 4: 求出系数的标准误\n\n感觉这一部分的可拓展性比较强，在不同的假设下（同方差、异方差等），系数的标准误不同。这次先假设同方差且无自相关（球星扰动项）。\n\n求一下自由度\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_freedom <- function(X) {\n  nrow(X) - ncol(X)\n}\nfreedom <- get_freedom(X)\nfreedom\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 994\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_err_sepherical <- function(err_vec) {\n  as.numeric(crossprod(err_vec, err_vec) / freedom)\n}\nerr <- get_err_sepherical(err_vec)\nerr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.479078e-27\n```\n:::\n:::\n\n\n球星扰动项假设下，系数的标准误为\n\n$$\n\\mathbf {\\text{SE}(\\hat{\\beta})} = \\mathbf {\\sqrt {e^2 (X^T X)^{-1}_{kk}}}\n$$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_beta_se <- function(X, err) {\n  sqrt(err * diag(solve(crossprod(X, X))))\n}\nbeta_se <- get_beta_se(X, err)\nbeta_se\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n (Intercept)           x1           x2          x3B          x3C          x3D \n3.166013e-15 2.137118e-16 2.126321e-16 3.311594e-15 3.479984e-15 3.454947e-15 \n```\n:::\n:::\n\n\n### step 5: 系数的t检验\n\n计算系数的t统计量\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_beta_t <- function(beta, assump = 0) {\n  (beta - assump) / beta_se\n}\nbeta_t <- get_beta_t(beta)\nbeta_t\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                    [,1]\n(Intercept) 6.317093e+14\nx1          9.358399e+15\nx2          1.410888e+16\nx3B         3.019694e+14\nx3C         5.747153e+14\nx3D         8.683202e+14\n```\n:::\n:::\n\n\n置信区间\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_conf <- function(beta, beta_se, freedom, p = 0.05) {\n  beta_lconf <- beta + qt(p, freedom) * beta_se\n  beta_hconf <- beta - qt(p, freedom) * beta_se\n  cbind(beta_lconf, beta_hconf)\n}\n\nconf <- get_conf(beta, beta_se, freedom)\nconf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1] [,2]\n(Intercept)    2    2\nx1             2    2\nx2             3    3\nx3B            1    1\nx3C            2    2\nx3D            3    3\n```\n:::\n:::\n\n\n\np-value\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_pvalue <- function(beta_t, freedom) {\n  1 - pt(abs(beta_t), freedom)\n}\npvalue <- get_pvalue(beta_t, freedom)\npvalue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]\n(Intercept)    0\nx1             0\nx2             0\nx3B            0\nx3C            0\nx3D            0\n```\n:::\n:::\n\n\n\n### step 6: 整理结果\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nresult_df <- as_tibble(beta,rownames = \"term\") %>% \n  rename(estimate = V1) %>% \n  bind_cols(low_conf = conf[, 1], high_conf = conf[, 2], p_value = pvalue)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n```\n:::\n\n```{.r .cell-code}\nresult_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  term        estimate low_conf high_conf p_value[,1]\n  <chr>          <dbl>    <dbl>     <dbl>       <dbl>\n1 (Intercept)     2.00     2.00      2.00           0\n2 x1              2        2         2              0\n3 x2              3.00     3.00      3              0\n4 x3B             1.00     1.00      1.00           0\n5 x3C             2        2.00      2.00           0\n6 x3D             3.00     3.00      3.00           0\n```\n:::\n:::\n\n\n\n# 打包成一个函数\n\n前面编写的函数有\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_beta <- function(X, Y) {\n  solve(crossprod(X, X)) %*% crossprod(X, Y)\n}\n\nget_fit <- function(X, beta) {\n  X %*% beta\n}\n\nget_err_vec <- function(Y, Y_hat) {\n  Y - Y_hat\n}\n\nget_freedom <- function(X) {\n  nrow(X) - ncol(X)\n}\n\nget_err_sepherical <- function(err_vec) {\n  as.numeric(crossprod(err_vec, err_vec) / freedom)\n}\n\nget_beta_se <- function(X, err) {\n  sqrt(err * diag(solve(crossprod(X, X))))\n}\n\nget_beta_t <- function(beta, assump = 0) {\n  (beta - assump) / beta_se\n}\n\nget_conf <- function(beta, beta_se, freedom, p = 0.05) {\n  beta_lconf <- beta + qt(p, freedom) * beta_se\n  beta_hconf <- beta - qt(p, freedom) * beta_se\n  cbind(beta_lconf, beta_hconf)\n}\n\nget_pvalue <- function(beta_t, freedom) {\n  1 - pt(abs(beta_t), freedom)\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_lm <- function(formula, df) {\n  formula <- y ~ x1 + x2 + x3\n  df_model <- model.frame(formula, df)\n  X <- model.matrix.lm(df_model)\n  Y <- model.response(df_model)\n  \n  beta <- get_beta(X, Y)\n  \n  Y_hat <- get_fit(X, beta)\n  err_vec <- get_err_vec(Y, Y_hat)\n  \n  freedom <- get_freedom(X)\n  err <- get_err_sepherical(err_vec)\n  \n  beta_se <- get_beta_se(X, err)\n  \n  beta_t <- get_beta_t(beta)\n  #conf <- get_conf(beta, beta_se, freedom)\n  pvalue <- get_pvalue(beta_t, freedom)\n  \n  \n  result_df <- as_tibble(beta,rownames = \"term\") %>% \n    rename(estimate = V1) %>% \n    bind_cols(#low_conf = conf[, 1], \n              #high_conf = conf[, 2], \n              std_erro = beta_se,\n              statistics = beta_t,\n              p_value = pvalue)\n  \n  return(result_df)\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_lm(y ~ x1 + x2 + x3, df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  term        estimate std_erro statistics[,1] p_value[,1]\n  <chr>          <dbl>    <dbl>          <dbl>       <dbl>\n1 (Intercept)     2.00 3.17e-15        6.32e14           0\n2 x1              2    2.14e-16        9.36e15           0\n3 x2              3.00 2.13e-16        1.41e16           0\n4 x3B             1.00 3.31e-15        3.02e14           0\n5 x3C             2    3.48e-15        5.75e14           0\n6 x3D             3.00 3.45e-15        8.68e14           0\n```\n:::\n:::\n\n\n对比一下`lm()`的结果\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlm(y ~ x1 + x2 + x3, df) %>% \n  broom::tidy()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in summary.lm(x): essentially perfect fit: summary may be unreliable\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  term        estimate std.error statistic p.value\n  <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)     2.00  3.83e-16   5.23e15       0\n2 x1              2     2.58e-17   7.74e16       0\n3 x2              3     2.57e-17   1.17e17       0\n4 x3B             1     4.00e-16   2.50e15       0\n5 x3C             2     4.21e-16   4.76e15       0\n6 x3D             3     4.18e-16   7.18e15       0\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}