{
  "hash": "c1aabd2ed66664acbbf6ebbdaede8228",
  "result": {
    "markdown": "---\ntitle: 实现简单线性回归\ncategories: [R, econometrics]\ndate: \"2024-04-09\"\ndate-modified: \"2024-04-11\"\nnumber-depth: 2\ntoc-depth: 3\n---\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ntheme_set(hrbrthemes::theme_ipsum_rc())\n```\n:::\n\n\n\n准备花几期时间，自己写代码，实现常用的计量方法。\n\n生成模拟数据\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(111)\nx <- 1:4\nnames(x) <- LETTERS[1:4]\ndf <- tibble(\n  x1 = runif(1000, -10, 10),\n  x2 = sample(1:20, 1000, replace = TRUE),\n  x3 = sample(LETTERS[1:4], 1000, replace = TRUE),\n  error = rnorm(1000, sd = 1000),\n  y = 1 + 2 * x1 + 3 * x2 + x[x3]\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 5\n       x1    x2 x3     error     y\n    <dbl> <int> <chr>  <dbl> <dbl>\n 1  1.86     11 A      285.  38.7 \n 2  4.53      5 B      176.  27.1 \n 3 -2.59     11 A     -610.  29.8 \n 4  0.298     9 A       92.1 29.6 \n 5 -2.45     20 D      611.  60.1 \n 6 -1.63     15 B      170.  44.7 \n 7 -9.79      6 C     -104.   2.43\n 8  0.646    18 A     -253.  57.3 \n 9 -1.36     10 B     -169.  30.3 \n10 -8.13      6 B     -509.   4.75\n# ℹ 990 more rows\n```\n:::\n:::\n\n\n# 步骤拆解\n\n### step 1: 根据formula生成矩阵\n\n因为`formula`是R里面一个特殊的`class`，他的具体机制我没弄清楚，所以这一步用R中的`model.matrix.lm()`实现\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ x1 + x2 + x3\ndf_model <- model.frame(formula, df)\nX <- model.matrix.lm(df_model)\nhead(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  (Intercept)         x1 x2 x3B x3C x3D\n1           1  1.8596257 11   0   0   0\n2           1  4.5296224  5   1   0   0\n3           1 -2.5915599 11   0   0   0\n4           1  0.2984766  9   0   0   0\n5           1 -2.4467357 20   0   0   1\n6           1 -1.6332535 15   1   0   0\n```\n:::\n\n```{.r .cell-code}\nY <- model.response(df_model)\nhead(Y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       1        2        3        4        5        6 \n38.71925 27.05924 29.81688 29.59695 60.10653 44.73349 \n```\n:::\n:::\n\n\n### step 2: 得到回归系数\n\n假设对于总体数据来说：\n\n$$\n\\mathbf Y = \\mathbf X \\boldsymbol \\beta + \\boldsymbol \\epsilon\n$$\n\n\n但是我们得到的拟合方程是：\n\n$$\n\\hat{\\mathbf Y} = \\mathbf X \\hat{\\boldsymbol \\beta}\n$$\n\n\n\n\n且\n\n$$\n\\begin{align}\n\\boldsymbol e &= \\mathbf Y - \\hat{\\mathbf Y} \\\\\n&= \\mathbf Y - \\mathbf X \\hat{\\boldsymbol \\beta}\n\\end{align}\n$$\n\n要想使$\\mathbf Y - \\hat{\\mathbf Y}$最小，则$\\boldsymbol e$与$\\mathbf X$正交，即\n\n\n$$\n\\begin{align}\n&\\mathbf {X^T (Y - X\\hat{\\beta})} = \\mathbf {0} \\\\\n&\\mathbf {\\hat{\\beta}} = \\mathbf {(X^T X)^{-1}X^{T} Y} \n\\end{align}\n$$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_beta <- function(X, Y) {\n  solve(crossprod(X, X)) %*% crossprod(X, Y)\n}\nbeta <- get_beta(X, Y)\nbeta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]\n(Intercept)    2\nx1             2\nx2             3\nx3B            1\nx3C            2\nx3D            3\n```\n:::\n:::\n\n\n### step 3: 求出拟合值和误差\n\n$$\n\\begin{align}\n\\mathbf{\\hat{Y}} &= \\mathbf{X\\hat{\\beta}} \\\\\n\\mathbf{e} &= \\mathbf{ Y - \\hat{Y}}\n\\end{align}\n$$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_fit <- function(X, beta) {\n  X %*% beta\n}\n\nY_hat <- get_fit(X, beta)\nhead(Y_hat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n1 38.71925\n2 27.05924\n3 29.81688\n4 29.59695\n5 60.10653\n6 44.73349\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_residual <- function(Y, Y_hat) {\n  Y - Y_hat\n}\nresidual <- get_residual(Y, Y_hat)\nhead(residual)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n1 -7.105427e-15\n2 -2.842171e-14\n3 -3.552714e-15\n4 -1.421085e-14\n5  2.842171e-14\n6  0.000000e+00\n```\n:::\n:::\n\n\n### step 4: 求出系数的标准误\n\n感觉这一部分的可拓展性比较强，在不同的假设下（同方差、异方差等），系数的标准误不同。这次先假设同方差且无自相关（球形扰动项）。\n\n求一下自由度\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_freedom <- function(X) {\n  nrow(X) - ncol(X)\n}\nfreedom <- get_freedom(X)\nfreedom\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 994\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_var_sepherical <- function(residual, freedom) {\n  as.numeric(crossprod(residual, residual) / freedom)\n}\nresidual_var <- get_var_sepherical(residual, freedom)\nresidual_var\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.95194e-28\n```\n:::\n:::\n\n\n球形扰动项假设下，系数的标准误为\n\n$$\n\\mathbf {\\text{SE}(\\hat{\\beta})} = \\mathbf {\\sqrt {\\text{Var}(e) (X^T X)^{-1}_{kk}}}\n$$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_beta_se <- function(X, residual_var) {\n  sqrt(residual_var * diag(solve(crossprod(X, X))))\n}\nbeta_se <- get_beta_se(X, residual_var)\nbeta_se\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n (Intercept)           x1           x2          x3B          x3C          x3D \n2.135352e-15 1.373596e-16 1.354870e-16 2.187586e-15 2.153656e-15 2.223240e-15 \n```\n:::\n:::\n\n\n### step 5: 系数的t值和p值\n\n计算系数的t值\n\n$$\nt_k = \\frac{\\hat{\\beta_k} - \\beta_k}{ \\text{SE}(\\hat{ \\beta_k}) }\n$$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_beta_t <- function(beta, beta_se, assump = 0) {\n  (beta - assump) / beta_se\n}\nbeta_t <- get_beta_t(beta, beta_se)\nbeta_t\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                    [,1]\n(Intercept) 9.366136e+14\nx1          1.456032e+16\nx2          2.214234e+16\nx3B         4.571248e+14\nx3C         9.286532e+14\nx3D         1.349382e+15\n```\n:::\n:::\n\n\n置信区间\n\n$$\n[\\hat{\\beta_k} - t_{\\frac{\\alpha}{2}} \\text{SE}(\\hat{ \\beta_k}),  \n\\hat{\\beta_k} + t_{\\frac{\\alpha}{2}} \\text{SE}(\\hat{ \\beta_k})]\n$$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_conf <- function(beta, beta_se, freedom, p = 0.05) {\n  beta_lconf <- beta + qt(p/2, freedom) * beta_se\n  beta_hconf <- beta - qt(p/2, freedom) * beta_se\n  cbind(beta_lconf, beta_hconf)\n}\n\nconf <- get_conf(beta, beta_se, freedom)\nconf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1] [,2]\n(Intercept)    2    2\nx1             2    2\nx2             3    3\nx3B            1    1\nx3C            2    2\nx3D            3    3\n```\n:::\n:::\n\n\n\n系数的p-value\n\n$$\np = P(|T| > |t_k|)\n$$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_pvalue <- function(beta_t, freedom) {\n  2 * pt(abs(beta_t), df = freedom, lower.tail = FALSE)\n}\npvalue <- get_pvalue(beta_t, freedom)\npvalue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]\n(Intercept)    0\nx1             0\nx2             0\nx3B            0\nx3C            0\nx3D            0\n```\n:::\n:::\n\n\n\n### step 6: 整理结果\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nresult_df <- as_tibble(beta, rownames = \"term\") %>% \n  rename(estimate = V1) %>% \n  bind_cols(std_error = beta_se,\n            statistics = beta_t[, 1],\n            p_value = pvalue[, 1])\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n```\n:::\n:::\n\n\n\n# 打包成一个函数\n\n前面编写的函数有\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_beta <- function(X, Y) {\n  solve(crossprod(X, X)) %*% crossprod(X, Y)\n}\n\nget_fit <- function(X, beta) {\n  X %*% beta\n}\n\nget_residual <- function(Y, Y_hat) {\n  Y - Y_hat\n}\n\nget_freedom <- function(X) {\n  nrow(X) - ncol(X)\n}\n\nget_var_sepherical <- function(residual, freedom) {\n  as.numeric(crossprod(residual, residual) / freedom)\n}\n\nget_beta_se <- function(X, residual) {\n  sqrt(residual * diag(solve(crossprod(X, X))))\n}\n\nget_beta_t <- function(beta, beta_se, assump = 0) {\n  (beta - assump) / beta_se\n}\n\nget_conf <- function(beta, beta_se, freedom, p = 0.05) {\n  beta_lconf <- beta + qt(p/2, freedom) * beta_se\n  beta_hconf <- beta - qt(p/2, freedom) * beta_se\n  cbind(beta_lconf, beta_hconf)\n}\n\nget_pvalue <- function(beta_t, freedom) {\n  2 * pt(abs(beta_t), df = freedom, lower.tail = FALSE)\n}\n```\n:::\n\n\n将这些函数作为积木拼入一个大函数中\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_lm <- function(formula, df) {\n  df_model <- model.frame(formula, df)\n  X <- model.matrix.lm(df_model)\n  Y <- model.response(df_model)\n  \n  beta <- get_beta(X, Y)\n  \n  Y_hat <- get_fit(X, beta)\n  residual <- get_residual(Y, Y_hat)\n  \n  freedom <- get_freedom(X)\n  residual_var <- get_var_sepherical(residual, freedom)\n  \n  beta_se <- get_beta_se(X, residual_var)\n  \n  beta_t <- get_beta_t(beta, beta_se)\n  #conf <- get_conf(beta, beta_se, freedom)\n  pvalue <- get_pvalue(beta_t, freedom)\n  \n  \n  result_df <- as_tibble(beta,rownames = \"term\") %>% \n    rename(estimate = V1) %>% \n    bind_cols(std_error = beta_se,\n              statistics = beta_t[, 1],\n              p_value = pvalue[, 1])\n  \n  return(result_df)\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_result <- my_lm(y ~ x1 + x2 + x3, df = df)\nmy_result\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  term        estimate std_error statistics p_value\n  <chr>          <dbl>     <dbl>      <dbl>   <dbl>\n1 (Intercept)     2.00  2.14e-15    9.37e14       0\n2 x1              2.00  1.37e-16    1.46e16       0\n3 x2              3     1.35e-16    2.21e16       0\n4 x3B             1     2.19e-15    4.57e14       0\n5 x3C             2.00  2.15e-15    9.29e14       0\n6 x3D             3.00  2.22e-15    1.35e15       0\n```\n:::\n:::\n\n\n# 和`lm()`的结果对比\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlm_result <- lm(y ~ x1 + x2 + x3, df) %>% \n  broom::tidy()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in summary.lm(x): essentially perfect fit: summary may be unreliable\n```\n:::\n\n```{.r .cell-code}\nlm_result\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  term        estimate std.error statistic p.value\n  <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)     2     9.24e-16   2.16e15       0\n2 x1              2     5.94e-17   3.37e16       0\n3 x2              3     5.86e-17   5.12e16       0\n4 x3B             1.00  9.47e-16   1.06e15       0\n5 x3C             2.00  9.32e-16   2.15e15       0\n6 x3D             3     9.62e-16   3.12e15       0\n```\n:::\n:::\n\n\n结果看起来不对，但其实是浮点数的数字存储机制造成的，比如\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsqrt(2) ^ 2 == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n这时应该使用`near()`来判断两个数是否相等\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnear(sqrt(2) ^ 2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnear(my_result$std_error, lm_result$std.error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)          x1          x2         x3B         x3C         x3D \n       TRUE        TRUE        TRUE        TRUE        TRUE        TRUE \n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnear(my_result$statistics, lm_result$statistic)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)          x1          x2         x3B         x3C         x3D \n      FALSE       FALSE       FALSE       FALSE       FALSE       FALSE \n```\n:::\n:::\n\n\n最终得到的t值不同，原因还不清楚。\n\n# 使用真实的数据集\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_lm(mpg ~ ., mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 5\n   term        estimate std_error statistics p_value\n   <chr>          <dbl>     <dbl>      <dbl>   <dbl>\n 1 (Intercept)  12.3      18.7         0.657  0.518 \n 2 cyl          -0.111     1.05       -0.107  0.916 \n 3 disp          0.0133    0.0179      0.747  0.463 \n 4 hp           -0.0215    0.0218     -0.987  0.335 \n 5 drat          0.787     1.64        0.481  0.635 \n 6 wt           -3.72      1.89       -1.96   0.0633\n 7 qsec          0.821     0.731       1.12   0.274 \n 8 vs            0.318     2.10        0.151  0.881 \n 9 am            2.52      2.06        1.23   0.234 \n10 gear          0.655     1.49        0.439  0.665 \n11 carb         -0.199     0.829      -0.241  0.812 \n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlm(mpg ~ ., mtcars) %>% \n  broom::tidy()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 5\n   term        estimate std.error statistic p.value\n   <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n 1 (Intercept)  12.3      18.7        0.657  0.518 \n 2 cyl          -0.111     1.05      -0.107  0.916 \n 3 disp          0.0133    0.0179     0.747  0.463 \n 4 hp           -0.0215    0.0218    -0.987  0.335 \n 5 drat          0.787     1.64       0.481  0.635 \n 6 wt           -3.72      1.89      -1.96   0.0633\n 7 qsec          0.821     0.731      1.12   0.274 \n 8 vs            0.318     2.10       0.151  0.881 \n 9 am            2.52      2.06       1.23   0.234 \n10 gear          0.655     1.49       0.439  0.665 \n11 carb         -0.199     0.829     -0.241  0.812 \n```\n:::\n:::\n\n\n这次得到的结果又完全一样。前面t值不同的原因比较复杂，可能是函数运算机制不同。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}